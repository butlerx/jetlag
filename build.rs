use serde::{Deserialize, Serialize};
use std::{env, fs, path::Path};

#[derive(Debug, Serialize, Deserialize, Clone)]
struct Field {
    id: String,
    label: String,
    description: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct Category {
    title: String,
    distance: Option<u32>,
    fields: Vec<Field>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct GameMode {
    title: String,
    categories: Vec<Category>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GameModesConfig {
    game_modes: Vec<GameMode>,
}

fn main() {
    println!("cargo:rerun-if-changed=game_modes.toml");

    let config = load_config("game_modes.toml");
    let generated_code = generate_complete_code(&config);

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("game_modes.rs");

    fs::write(&dest_path, generated_code).expect("Failed to write generated game modes file");
    println!("cargo:rustc-env=GAME_MODES_FILE={}", dest_path.display());
}

fn load_config(path: &str) -> GameModesConfig {
    let toml_content = fs::read_to_string(path).expect("Failed to read game_modes.toml");
    toml::from_str(&toml_content).expect("Failed to parse game_modes.toml")
}

fn generate_complete_code(config: &GameModesConfig) -> String {
    let code_sections = [
        |_| "// This file is generated by build.rs\n// DO NOT EDIT MANUALLY\n\n".to_string(),
        |config| generate_game_modes_array(config),
        |config| generate_helper_functions(config),
    ];

    code_sections
        .iter()
        .map(|generator| generator(config))
        .collect::<String>()
}

fn generate_game_modes_array(config: &GameModesConfig) -> String {
    let game_modes_content = config
        .game_modes
        .iter()
        .map(generate_game_mode)
        .collect::<String>();

    format!(
        "pub static GAME_MODES: &[GameMode] = &[{}];\n\n",
        game_modes_content
    )
}

fn generate_game_mode(game_mode: &GameMode) -> String {
    let categories_content = game_mode
        .categories
        .iter()
        .map(generate_category)
        .collect::<String>();

    format!(
        "GameMode {{ title: \"{}\", categories: &[{}], }},",
        escape_string(&game_mode.title),
        categories_content
    )
}

fn generate_category(category: &Category) -> String {
    let distance_str = format_option(category.distance.as_ref(), |d| format!("Some({})", d));
    let fields_content = category
        .fields
        .iter()
        .map(generate_field)
        .collect::<String>();

    format!(
        "Category {{ title: \"{}\", distance: {}, fields: &[{}], }},",
        escape_string(&category.title),
        distance_str,
        fields_content
    )
}

fn generate_field(field: &Field) -> String {
    let description_str = format_option(field.description.as_ref(), |d| {
        format!("Some(\"{}\")", escape_string(d))
    });

    format!(
        "Field {{ id: \"{}\", label: \"{}\", description: {}, }},",
        escape_string(&field.id),
        escape_string(&field.label),
        description_str
    )
}

fn generate_helper_functions(config: &GameModesConfig) -> String {
    config
        .game_modes
        .iter()
        .map(generate_helper_function)
        .collect::<String>()
}

fn generate_helper_function(game_mode: &GameMode) -> String {
    let function_name = format!("{}_mode", game_mode.title.replace("-", "_"));
    format!(
        "pub fn {} () -> &'static GameMode {{
    GAME_MODES.iter().find(|gm| gm.title == \"{}\").expect(\"{} mode not found\")
}}

",
        function_name,
        escape_string(&game_mode.title),
        game_mode.title
    )
}

fn format_option<T, F>(option: Option<&T>, formatter: F) -> String
where
    F: FnOnce(&T) -> String,
{
    option.map(formatter).unwrap_or_else(|| "None".to_string())
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}
